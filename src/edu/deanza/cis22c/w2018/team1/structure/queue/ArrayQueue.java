package edu.deanza.cis22c.w2018.team1.structure.queue;import java.util.Arrays;/** * A class that implements the ADT queue by using an expandable * circular array with one unused location after the back of the queue. * * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.1 * UPDATED BY C. Lee-Klawender * UPDATED BY D. Danilovic */public final class ArrayQueue<T> implements QueueInterface<T> {	private T[] queue; // Circular array of queue entries	private int frontIndex; // Index of front entry	private int backIndex;  // Index of back entry	private int count;	private static final int DEFAULT_CAPACITY = 10;	private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // Taken from ArrayList	public ArrayQueue() {		this(DEFAULT_CAPACITY);	} // end default constructor	public ArrayQueue(int initialCapacity) {		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] tempQueue = (T[]) new Object[Math.max(initialCapacity, DEFAULT_CAPACITY)];		queue = tempQueue;		frontIndex = 0;		backIndex = queue.length - 1;		count = 0;	}	/**	 * Increases the capacity of this {@code ArrayQueue} instance, if	 * necessary, to ensure that it can hold at least the number of elements	 * specified by the minimum capacity argument.	 *	 * @param   capacity   the desired minimum capacity	 */	public void ensureCapacity(int capacity) { // adapted from ArrayList implementation		int oldCapacity = queue.length;		if (oldCapacity - capacity > 0) { return; }		int newCapacity = oldCapacity + (oldCapacity >> 1); // newCapacity is 1.5 * oldCapacity		if (newCapacity - capacity < 0) // check for overflow			newCapacity = capacity;		if (newCapacity - MAX_ARRAY_SIZE > 0)			newCapacity = hugeCapacity(capacity);		if (isEmpty() || frontIndex <= backIndex) { // queue does not wrap			queue = Arrays.copyOf(queue, newCapacity);		} else {			@SuppressWarnings("unchecked")			T[] newQueue = (T[]) new Object[newCapacity];			int frSliceLength = queue.length - frontIndex;			System.arraycopy(queue, frontIndex, newQueue, 0, frSliceLength);			System.arraycopy(queue, 0, newQueue, frSliceLength, backIndex + 1);			queue = newQueue;			frontIndex = 0;			backIndex = count - 1;		}	}	private static int hugeCapacity(int minCapacity) {		if (minCapacity < 0) // overflow			throw new OutOfMemoryError();		return (minCapacity > MAX_ARRAY_SIZE) ?				Integer.MAX_VALUE :				MAX_ARRAY_SIZE;	}	@Override	public boolean enqueue(T newEntry) {		ensureCapacity(count + 1);		backIndex = (backIndex + 1) % queue.length;		queue[backIndex] = newEntry;		++count;		return true;	}	@Override	public T peekFront() {		if (isEmpty())			return null;		return queue[frontIndex];	}	@Override	public T dequeue() {		if (isEmpty())			return null;		else {			--count;			T temp = queue[frontIndex];			queue[frontIndex] = null;			frontIndex = (frontIndex + 1) % queue.length;			return temp;		}	}	@Override	public boolean isEmpty() {		return count == 0;	}	@Override	public int size() {		return count;	}}